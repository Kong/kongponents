<template>
  <div class="k-card-catalog">
    <div
      v-if="title"
      class="k-card-catalog-title"
      data-testid="k-catalog-title"
    >
      <h3>{{ title }}</h3>
    </div>

    <KSkeleton
      v-if="(testMode === false || testMode === 'loading') && (isCardLoading || isLoading) && !hasError"
      :card-count="4"
      type="card"
      class="k-skeleton-grid"
      data-testid="k-catalog-skeleton"
    >
      <template #card-header>
        <KSkeletonBox
          width="6"
          class="w-100 justify-content-center mb-3"
        />
      </template>

      <template #card-content>
        <KSkeletonBox width="75" />
      </template>

      <template #card-footer>
        <div class="d-flex justify-content-start">
          <KSkeletonBox
            width="2"
            class="mr-2"
          />
          <KSkeletonBox width="5" />
        </div>
      </template>
    </KSkeleton>

    <div
      v-else-if="hasError"
      data-testid="k-card-catalog-error-state"
    >
      <slot name="error-state">
        <KEmptyState
          is-error
          :cta-is-hidden="!errorStateActionMessage || !errorStateActionRoute"
          :icon="errorStateIcon || ''"
          :icon-color="errorStateIconColor"
          :icon-size="errorStateIconSize"
        >
          <template #title>
            {{ errorStateTitle }}
          </template>

          <template #message>
            {{ errorStateMessage }}
          </template>

          <template #cta>
            <KButton
              v-if="errorStateActionMessage"
              :to="errorStateActionRoute ? errorStateActionRoute : undefined"
              appearance="primary"
              :data-testid="getTestIdString(errorStateActionMessage)"
              @click="$emit('kcatalog-error-cta-clicked')"
            >
              {{ errorStateActionMessage }}
            </KButton>
          </template>
        </KEmptyState>
      </slot>
    </div>

    <div
      v-else-if="!hasError && (!isCardLoading && !isLoading) && (data && !data.length)"
      data-testid="k-card-catalog-empty-state"
    >
      <slot name="empty-state">
        <KEmptyState
          :cta-is-hidden="!emptyStateActionMessage || !emptyStateActionRoute"
          :icon="emptyStateIcon || ''"
          :icon-color="emptyStateIconColor"
          :icon-size="emptyStateIconSize"
        >
          <template #title>
            {{ emptyStateTitle }}
          </template>

          <template #message>
            {{ emptyStateMessage }}
          </template>

          <template #cta>
            <KButton
              v-if="emptyStateActionMessage"
              :to="emptyStateActionRoute ? emptyStateActionRoute : undefined"
              :icon="emptyStateActionButtonIcon"
              appearance="primary"
              :data-testid="getTestIdString(errorStateActionMessage)"
              @click="$emit('kcatalog-empty-state-cta-clicked')"
            >
              {{ emptyStateActionMessage }}
            </KButton>
          </template>
        </KEmptyState>
      </slot>
    </div>

    <div
      v-else
      :class="`k-card-${cardSize}`"
      class="k-catalog-page"
    >
      <slot
        :data="data"
        name="body"
      >
        <template v-for="(item, idx) in data">
          <router-link
            v-if="item.locationParam"
            :key="item.key ? item.key : `k-catalog-item-${idx}`"
            :data-testid="item.id ? item.id : `k-catalog-item-${idx}`"
          >
            <KCatalogItem
              :item="item"
              :location-param="item.locationParam"
              :truncate="!noTruncation"
              :test-mode="!!testMode"
              class="catalog-item"
            >
              <template #cardTitle>
                <slot
                  :item="item"
                  name="cardTitle"
                >
                  {{ item.title }}
                </slot>
              </template>

              <template #cardBody>
                <slot
                  :item="item"
                  name="cardBody"
                >
                  {{ item.description }}
                </slot>
              </template>
            </KCatalogItem>
          </router-link>

          <KCatalogItem
            v-else
            :key="item.key ? item.key : `k-catalog-item-${idx}`"
            :item="item"
            :truncate="!noTruncation"
            :test-mode="!!testMode"
            class="catalog-item"
            :data-testid="item.id ? item.id : `k-catalog-item-${idx}`"
          >
            <template #cardTitle>
              <slot
                :item="item"
                name="cardTitle"
              >
                {{ item.title }}
              </slot>
            </template>

            <template #cardBody>
              <slot
                :item="item"
                name="cardBody"
              >
                {{ item.description }}
              </slot>
            </template>
          </KCatalogItem>
        </template>
      </slot>

      <div
        v-if="!disablePagination && fetcher"
        class="card-pagination"
        data-testid="k-catalog-pagination"
      >
        <KPagination
          :initial-page-size="pageSize"
          :current-page="page"
          :page-sizes="paginationPageSizes"
          :neighbors="paginationNeighbors"
          :total-count="total"
          :disable-page-jump="disablePaginationPageJump"
          :test-mode="!!testMode"
          class="pa-1"
          @page-changed="pageChangeHandler"
          @page-size-changed="pageSizeChangeHandler"
        />
      </div>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, PropType, ref, computed, onMounted, watch } from 'vue'
import useUtilities from '@/composables/useUtilities'
import KButton from '@/components/KButton/KButton.vue'
import KEmptyState from '@/components/KEmptyState/KEmptyState.vue'
import KPagination from '@/components/KPagination/KPagination.vue'
import KSkeleton from '@/components/KSkeleton/KSkeleton.vue'
import KSkeletonBox from '@/components/KSkeleton/KSkeletonBox.vue'
import KCatalogItem from './KCatalogItem.vue'

const { useRequest, useDebounce } = useUtilities()

export default defineComponent({
  name: 'KCatalog',
  components: {
    KButton,
    KCatalogItem,
    KEmptyState,
    KPagination,
    KSkeleton,
    KSkeletonBox,
  },
  props: {
    /**
     * A prop to pass in to display skeleton to indicate loading
     */
    isLoading: {
      type: Boolean,
      default: false,
    },
    cardSize: {
      type: String,
      default: 'medium',
      validator: (value: string): boolean => {
        return ['small', 'medium', 'large'].includes(value)
      },
    },
    /**
     * Card catalog title
     */
    title: {
      type: String,
      default: '',
    },
    /**
     * Disable truncation of the KCard's 'description'
     */
    noTruncation: {
      type: Boolean,
      default: false,
    },
    /**
     * A prop to pass in a custom empty state title
     */
    emptyStateTitle: {
      type: String,
      default: 'No Data',
    },
    /**
     * A prop to pass in a custom empty state message
     */
    emptyStateMessage: {
      type: String,
      default: 'There is no data to display.',
    },
    /**
     * A prop to pass in a custom empty state action route
     */
    emptyStateActionRoute: {
      type: [Object, String],
      default: '',
    },
    /**
     * A prop to pass in a custom empty state action message
     */
    emptyStateActionMessage: {
      type: String,
      default: '',
    },
    /**
     * A prop to pass in a custom empty state action message
     */
    emptyStateActionButtonIcon: {
      type: String,
      default: '',
    },
    /**
     * A prop to pass in a custom empty state icon
     */
    emptyStateIcon: {
      type: String,
      default: '',
    },
    /**
     * A prop to pass in a color for the empty state icon
     */
    emptyStateIconColor: {
      type: String,
      default: '',
    },
    /**
     * A prop to pass in a size for the empty state icon
     */
    emptyStateIconSize: {
      type: String,
      default: '50',
    },
    /**
     * A prop that enables the error state
     */
    hasError: {
      type: Boolean,
      default: false,
    },
    /**
     * A prop to pass in a custom error state title
     */
    errorStateTitle: {
      type: String,
      default: 'An error occurred',
    },
    /**
     * A prop to pass in a custom error state message
     */
    errorStateMessage: {
      type: String,
      default: 'Data cannot be displayed due to an error.',
    },
    /**
     * A prop to pass in a custom error state action route
     */
    errorStateActionRoute: {
      type: [Object, String],
      default: '',
    },
    /**
     * A prop to pass in a custom error state action message
     */
    errorStateActionMessage: {
      type: String,
      default: '',
    },
    /**
     * A prop to pass in a custom error state icon
     */
    errorStateIcon: {
      type: String,
      default: '',
    },
    /**
     * A prop to pass in a color for the error state icon
     */
    errorStateIconColor: {
      type: String,
      default: '',
    },
    /**
     * A prop to pass in a size for the error state icon
     */
    errorStateIconSize: {
      type: String,
      default: '50',
    },
    /**
     * A prop to pass in a fetcher function to enable server-side pagination
     */
    fetcher: {
      type: Function,
      required: true,
    },
    /**
     * A prop to pass in a an object of intial params for the initial fetcher function call
     */
    initialFetcherParams: {
      type: Object,
      default: null,
    },
    /**
     * A prop to trigger a revalidate of the fetcher function. Modifying this value
     * will trigger a manual refetch of the table data.
     */
    fetcherCacheKey: {
      type: String,
      default: '',
    },
    /**
     * A prop to pass in a search string for server-side search
     */
    searchInput: {
      type: String,
      default: '',
    },
    /**
     * A prop to pass in a the number of pagination neighbors used by the pagination component
     */
    paginationNeighbors: {
      type: Number,
      default: 1,
    },
    /**
     * A prop to pass in an array of page sizes used by the pagination component
     */
    paginationPageSizes: {
      type: Array as PropType<number[]>,
      default: () => ([15, 30, 50, 75, 100]),
      validator: (pageSizes: number[]): boolean => !!pageSizes.length && pageSizes.every(i => typeof i === 'number'),
    },
    /**
     * A prop to pass the total number of items in the set for the pagination text
     */
    paginationTotalItems: {
      type: Number,
      default: null,
    },
    disablePaginationPageJump: {
      type: Boolean,
      default: false,
    },
    disablePagination: {
      type: Boolean,
      default: false,
    },
    /**
     * for testing only, strips out generated ids and avoid loading state in tests.
     * 'true' - no id's no loading
     * 'loading' - no id's but allow loading
     */
    testMode: {
      type: [String, Boolean],
      default: false,
    },
  },
  emits: ['kcatalog-error-cta-clicked', 'kcatalog-empty-state-cta-clicked'],
  setup(props) {
    const defaultFetcherProps = {
      page: 1,
      pageSize: 15,
      query: '',
    }

    const data = ref<any[]>([])
    const total = ref(0)
    const filterQuery = ref('')
    const page = ref(1)
    const pageSize = ref(15)
    const isCardLoading = ref(true)
    const hasInitialized = ref(false)

    const fetchData = async () => {
      isCardLoading.value = true
      const searchInput = props.searchInput
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      const res = await props.fetcher({
        query: searchInput || filterQuery.value,
        pageSize: pageSize.value,
        page: page.value,
      })

      data.value = res.data
      total.value = props.paginationTotalItems || res.total || res.data.length
      isCardLoading.value = false

      return res
    }

    const initData = async () => {
      // set up fetcher props
      const fetcherParams = {
        ...defaultFetcherProps,
        ...props.initialFetcherParams,
      }

      page.value = fetcherParams.page
      pageSize.value = fetcherParams.pageSize
      filterQuery.value = fetcherParams.query
      hasInitialized.value = true
    }

    // once `initData()` finishes fetch data
    const catalogFetcherCacheKey = computed(() => {
      if (!props.fetcher || !hasInitialized.value) {
        return ''
      }

      return `catalog-item_${Math.floor(Math.random() * 1000)}_${props.fetcherCacheKey}` as string
    })
    const { query, search } = useDebounce('', 350)
    const { revalidate } = useRequest(
      () => catalogFetcherCacheKey.value,
      () => fetchData(),
      { revalidateOnFocus: false },
    )

    const pageChangeHandler = ({ page: newPage }: Record<string, number>) => {
      page.value = newPage
    }

    const pageSizeChangeHandler = ({ pageSize: newPageSize }: Record<string, number>) => {
      pageSize.value = newPageSize
    }

    const getTestIdString = (message: string) => {
      return message.toLowerCase().replace(/[^[a-z0-9]/gi, '-')
    }

    watch(() => props.searchInput, (newValue: string) => {
      search(newValue)
    }, { immediate: true })

    watch(() => [query.value, page.value, pageSize.value], () => {
      revalidate()
    }, { immediate: true })

    onMounted(() => {
      initData()
    })

    return {
      data,
      isCardLoading,
      page,
      pageChangeHandler,
      pageSize,
      pageSizeChangeHandler,
      total,
      getTestIdString,
    }
  },
})
</script>

<style lang="scss" scoped>
@import '@/styles/variables';

.k-card-catalog {
  .k-card-catalog-title {
    color: var(--blue-600);
  }

  .k-catalog-page {
    display: grid;
    grid-gap: var(--spacing-lg);
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  }
}
</style>

<style lang="scss">
@import '@/styles/variables';

.k-card-catalog {
  $cardHeight: 181px;

  .k-skeleton-grid {
    --KSkeletonCardWidth: 25%;

    .skeleton-card-column {
      padding-right: 2rem;
    }
    .skeleton-card {
      height: $cardHeight;
    }
  }

  .k-catalog-page {
    &.k-card-small {
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    }

    &.k-card-large {
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    }

    a.catalog-item, a.catalog-item:focus, a.catalog-item:hover {
      text-decoration: none;
    }
  }

  .card-pagination {
    grid-column: 1 / -1;
  }
}
</style>
